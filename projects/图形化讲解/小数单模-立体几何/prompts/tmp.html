<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>步骤描述</title>
    <style>
        body {
            margin: 0;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        svg {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        const SVG_NS = "http://www.w3.org/2000/svg";

        const container = document.createElement("div");
        container.className = "container";

        const svg = document.createElementNS(SVG_NS, "svg");
        const svg_width = 960
        const svg_height = 540
        svg.setAttribute("width", svg_width);
        svg.setAttribute("height", svg_height);
        svg.setAttribute("viewBox", `0 0 ${svg_width} ${svg_height}`);
        svg.setAttribute("role", "img");
        svg.setAttribute("id", "立体几何题目讲解");
        window.mainSvg = svg; 

        const title = document.createElementNS(SVG_NS, "title");
        title.setAttribute("id", "title-1");
        title.textContent = "步骤描述";

        const desc = document.createElementNS(SVG_NS, "desc");
        desc.setAttribute("id", "desc-1");
        desc.textContent = "步骤描述";

        svg.appendChild(title);
        svg.appendChild(desc);
        container.appendChild(svg);
        document.body.appendChild(container);

    </script>
    <script id="lib-functions">
        // =====================
        // 1) 几何体统一默认样式
        // =====================
        const DEFAULT_STYLES = {
            // --- 边线 (visible edges) ---
            edgeStroke: "#333",        // 边线颜色
            edgeWidth: 2,              // 边线宽度
            edgeOpacity: 1,            // 边线透明度
            edgeLinecap: "round",      // butt | round | square
            edgeLinejoin: "round",     // miter | round | bevel
            edgeMiterlimit: 4,         // join=miter 时的尖角限制

            // --- 不可见线 (hidden edges) ---
            dashArray: "5,5",          // 兼容旧字段：不可见线默认虚线样式（你现有代码用这个）
            hiddenDashArray: "5,5",    // 推荐新字段：专门给 hidden 用
            hiddenStroke: "#333",      // 可设置为更淡，比如 "#666"
            hiddenWidth: null,         // null 表示沿用 edgeWidth；也可单独设置
            hiddenOpacity: 1,          // 可设置为 0.8/0.6 更像工程制图

            // --- 面 (faces) ---
            faceFill: "rgba(0,0,0,0)", // 面填充色 (默认透明)
            faceOpacity: 1,            // 面整体透明度（可配合 faceFill 使用）
            faceStroke: "none",        // 面描边颜色（默认不描边）
            faceStrokeWidth: 0,        // 面描边宽度
            faceStrokeOpacity: 1,      // 面描边透明度

            // --- 顶点 (vertices) ---
            showVertices: false,       // 是否显示顶点
            vertexRadius: 4,           // 顶点半径
            vertexFill: "#333",        // 顶点填充
            vertexStroke: "none",      // 顶点描边
            vertexStrokeWidth: 0,      // 顶点描边宽度
            vertexOpacity: 1,          // 顶点透明度

            // --- 圆类细分 (cylinder/cone smoothing) ---
            segments: 72,              // 圆周分段数（圆柱/圆锥默认可读这个）

            // --- 调试辅助 ---
            showCenters: false,        // 是否显示几何中心点（圆柱/圆锥等）
            centerRadius: 3,
            centerFill: "#e11d48",     // 调试用醒目色
            debug: false               // true 时可让你的绘制函数加额外辅助元素/更醒目样式
        };

        // =====================
        // 2) 标注/箭头统一默认样式（建议）
        //   适用于 drawArrow / drawDimensionLabel / drawCurlyBraceLabel / drawDirectLabel
        // =====================
        const DEFAULT_ANNOTATION_STYLES = {
            // --- 线条/箭头通用 ---
            stroke: "#333",
            strokeWidth: 1.5,
            opacity: 1,
            linecap: "round",
            linejoin: "round",
            dashArray: null,           // null 表示实线；如 "4,4"

            fill: "#333",              // 箭头/实体符号填充色

            // --- 文字通用 ---
            fontSize: 14,
            fontFamily: "Arial, sans-serif",
            textFill: "#333",

            // 文字光晕（你现在是白描边 halo）
            haloStroke: "white",
            haloWidth: 3,
            haloLinejoin: "round",

            // 可选：强背景（比 halo 更“遮挡线条”）
            textBackground: false,
            textBgFill: "white",
            textBgOpacity: 1,
            textBgPadding: 3,          // 背景 padding（需要你在代码里用 <rect> 实现）

            // --- 箭头参数（arrow/dim/direct 都可能用到） ---
            arrowSize: 8,
            arrowWidth: 3,

            // --- 尺寸标注特有（drawDimensionLabel） ---
            textOffset: 13,
            gap: 15,
            ext_length: 10,

            // --- 花括号特有（drawCurlyBraceLabel） ---
            braceDepth: 10,
            braceGap: 15,

            // --- 原地/辅助线标注特有（drawDirectLabel） ---
            directDashArray: "4,4",
            directArrowStart: true,
            directArrowEnd: true
        };
        const Projections = {
            /** 
             * 策略 A: 斜二测 (数学标准，适合组合)
             * 特点：X轴随Z轴偏移，圆是歪的
             */
            OBLIQUE: function(x, y, z, config) {
                const { centerX, centerY, k = 0.5, angle = Math.PI / 4 } = config;
                return {
                    px: centerX + x + z * k * Math.cos(angle),
                    py: centerY - (y + z * k * Math.sin(angle))
                };
            },

            /** 
             * 策略 B: 正视图 (视觉优化，适合单独圆柱)
             * 特点：X轴不变，圆是平的
             */
            FRONT: function(x, y, z, config) {
                const { centerX, centerY, k = 0.3 } = config;
                return {
                    px: centerX + x,
                    py: centerY - (y + z * k)
                };
            }
        };
        
        /**
         * 绘制长方体 (支持自定义投影策略)
         *
         * @param {Object} config - 长方体配置对象
         * @param {string} config.id - SVG 元素的唯一 ID 前缀
         * @param {number} [config.x=0] - 左下前（靠近观察者）顶点 x (3D)
         * @param {number} [config.y=0] - 左下前（靠近观察者）顶点 y (3D)
         * @param {number} [config.z=0] - 左下前（靠近观察者）顶点 z (3D)
         * @param {number} config.w - 宽 (X轴跨度)
         * @param {number} config.h - 高 (Y轴跨度)
         * @param {number} config.d - 深 (Z轴跨度)
         * @param {number} config.centerX - 画布中心点 X（供投影函数使用）
         * @param {number} config.centerY - 画布中心点 Y（供投影函数使用）
         * @param {Function} [config.projectFn] - 投影函数 (例如 Projections.OBLIQUE)
         * @param {Object} [config.styles] - 样式覆盖（基于 DEFAULT_STYLES）
         * @returns {SVGGElement} g
         */
        function drawCuboid(config) {
            const {
                id,
                x = 0, y = 0, z = 0,
                w, h, d,
                styles = {},
                projectFn = Projections.OBLIQUE
            } = config;

            if (!id) throw new Error("drawCuboid: config.id is required.");
            if (w == null || h == null || d == null) throw new Error("drawCuboid: config.w/h/d are required.");

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawCuboid: global svg not found.");

            const s = { ...DEFAULT_STYLES, ...styles };

            // ---------- 样式应用：边/隐藏边/面/点 ----------
            const applyVisibleStroke = (el) => {
                el.setAttribute("stroke", s.edgeStroke);
                el.setAttribute("stroke-width", s.edgeWidth);
                if (s.edgeOpacity != null) el.setAttribute("stroke-opacity", s.edgeOpacity);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
            };

            const applyHiddenStroke = (el) => {
                const hs = (s.hiddenStroke != null) ? s.hiddenStroke : s.edgeStroke;
                const hw = (s.hiddenWidth != null) ? s.hiddenWidth : s.edgeWidth;
                const ho = (s.hiddenOpacity != null) ? s.hiddenOpacity : s.edgeOpacity;
                const hd = (s.hiddenDashArray != null) ? s.hiddenDashArray : s.dashArray;

                el.setAttribute("stroke", hs);
                el.setAttribute("stroke-width", hw);
                if (ho != null) el.setAttribute("stroke-opacity", ho);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
                if (hd) el.setAttribute("stroke-dasharray", hd);
            };

            const applyFaceStyle = (poly) => {
                poly.setAttribute("fill", s.faceFill);
                if (s.faceOpacity != null) poly.setAttribute("fill-opacity", s.faceOpacity);

                if (s.faceStroke && s.faceStroke !== "none" && (s.faceStrokeWidth || 0) > 0) {
                    poly.setAttribute("stroke", s.faceStroke);
                    poly.setAttribute("stroke-width", s.faceStrokeWidth);
                    if (s.faceStrokeOpacity != null) poly.setAttribute("stroke-opacity", s.faceStrokeOpacity);
                    if (s.edgeLinecap) poly.setAttribute("stroke-linecap", s.edgeLinecap);
                    if (s.edgeLinejoin) poly.setAttribute("stroke-linejoin", s.edgeLinejoin);
                } else {
                    poly.setAttribute("stroke", "none");
                }
            };

            const applyVertexStyle = (c) => {
                c.setAttribute("r", s.vertexRadius);
                c.setAttribute("fill", s.vertexFill);
                if (s.vertexOpacity != null) c.setAttribute("fill-opacity", s.vertexOpacity);

                if (s.vertexStroke && s.vertexStroke !== "none" && (s.vertexStrokeWidth || 0) > 0) {
                    c.setAttribute("stroke", s.vertexStroke);
                    c.setAttribute("stroke-width", s.vertexStrokeWidth);
                } else {
                    c.setAttribute("stroke", "none");
                }
            };

            // ---------- 1) 8 个顶点（3D） ----------
            // 约定：0-3 为前表面(z)，4-7 为后表面(z+d)
            // 0: 左下前, 1: 右下前, 2: 右上前, 3: 左上前
            // 4: 左下后, 5: 右下后, 6: 右上后, 7: 左上后
            const v3d = [
                [x,   y,   z],     [x+w, y,   z],     [x+w, y+h, z],     [x,   y+h, z],
                [x,   y,   z+d],   [x+w, y,   z+d],   [x+w, y+h, z+d],   [x,   y+h, z+d]
            ];

            // ---------- 2) 投影到 2D ----------
            const pts = v3d.map(v => projectFn(v[0], v[1], v[2], config));

            // ---------- 3) 面拓扑（先给“常识顺序”，后面会自动修正 winding） ----------
            const facesTopology = [
                { name: "front",  idx: [0, 1, 2, 3] },
                { name: "back",   idx: [4, 5, 6, 7] },
                { name: "right",  idx: [1, 2, 6, 5] },
                { name: "left",   idx: [0, 4, 7, 3] },
                { name: "top",    idx: [3, 7, 6, 2] },
                { name: "bottom", idx: [0, 1, 5, 4] }
            ];

            // ---------- 4) 自动修正 face winding + 再算 faceVisibility ----------
            const v3sub = (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            const v3dot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
            const v3cross = (a, b) => [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0],
            ];
            const v3len = (a) => Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
            const v3norm = (a) => {
                const L = v3len(a);
                if (L < 1e-12) return [0, 0, 0];
                return [a[0]/L, a[1]/L, a[2]/L];
            };

            const faceNormal3D = (idx) => {
                const A = v3d[idx[0]];
                const B = v3d[idx[1]];
                const C = v3d[idx[2]];
                return v3cross(v3sub(B, A), v3sub(C, A));
            };

            // 期望“朝外”的法线方向（基于 v3d 编号约定）
            const EXPECT_OUTWARD = {
                front:  [0, 0, -1],
                back:   [0, 0,  1],
                right:  [1, 0,  0],
                left:   [-1,0,  0],
                top:    [0, 1,  0],
                bottom: [0,-1,  0],
            };

            // 4.1) 先修正 winding：让每个面的法线与“期望外法线”同向
            facesTopology.forEach(face => {
                const exp = EXPECT_OUTWARD[face.name];
                if (!exp) return;
                const n = faceNormal3D(face.idx);
                if (v3dot(n, exp) < 0) {
                    face.idx = [...face.idx].reverse();
                }
            });

            // 4.2) 估计 viewDir（对 OBLIQUE/FRONT 这类线性投影很稳）
            const estimateViewDir = () => {
                const eps = 1;
                const p0 = projectFn(0, 0, 0, config);
                const px = projectFn(eps, 0, 0, config);
                const py = projectFn(0, eps, 0, config);
                const pz = projectFn(0, 0, eps, config);

                const row1 = [(px.px - p0.px)/eps, (py.px - p0.px)/eps, (pz.px - p0.px)/eps];
                const row2 = [(px.py - p0.py)/eps, (py.py - p0.py)/eps, (pz.py - p0.py)/eps];

                const v = v3cross(row1, row2);
                const vn = v3norm(v);
                return (v3len(vn) < 1e-9) ? [0, 0, -1] : vn;
            };

            const viewDir0 = estimateViewDir();

            // 4.3) 用 2D 面积符号做一次“手性/正负号”校准（避免 viewDir 符号不确定）
            const faceArea2D = (idx) => {
                let area = 0;
                for (let i = 0; i < idx.length; i++) {
                    const p1 = pts[idx[i]];
                    const p2 = pts[idx[(i + 1) % idx.length]];
                    area += (p1.px * p2.py - p2.px * p1.py);
                }
                return area;
            };

            // 选择最佳组合：flipViewDir? 以及 areaSign(neg/pos) 与 3D 可见性的一致性
            const combos = [
                { flipView: false, areaNegIsFront: true  },
                { flipView: false, areaNegIsFront: false },
                { flipView: true,  areaNegIsFront: true  },
                { flipView: true,  areaNegIsFront: false },
            ];

            const EPS_AREA = 1e-6;
            const EPS_DOT  = 1e-6;

            let best = { score: -1, flipView: false, areaNegIsFront: true };
            combos.forEach(c => {
                const vd = c.flipView ? [-viewDir0[0], -viewDir0[1], -viewDir0[2]] : viewDir0;
                let score = 0;
                let total = 0;

                facesTopology.forEach(face => {
                    const n = v3norm(faceNormal3D(face.idx));
                    if (v3len(n) < 1e-9) return;

                    const a = faceArea2D(face.idx);
                    if (Math.abs(a) < EPS_AREA) return;

                    const vis3 = v3dot(n, vd) > EPS_DOT;
                    const vis2 = c.areaNegIsFront ? (a < 0) : (a > 0);

                    score += (vis3 === vis2) ? 1 : 0;
                    total += 1;
                });

                // 用一致比例评分（避免 total 少导致误判）
                const ratio = total ? (score / total) : 0;
                if (ratio > best.score) best = { ...c, score: ratio };
            });

            const viewDir = best.flipView ? [-viewDir0[0], -viewDir0[1], -viewDir0[2]] : viewDir0;

            const faceVisibility = {};
            facesTopology.forEach(face => {
                const n = v3norm(faceNormal3D(face.idx));
                faceVisibility[face.name] = v3dot(n, viewDir) > EPS_DOT;
            });

            // ---------- 5) 组 ----------
            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // ---------- 6) 先绘制面（保证边在线上层） ----------
            facesTopology.forEach(face => {
                const poly = document.createElementNS(SVG_NS, "polygon");
                poly.setAttribute("id", `${id}-face-${face.name}`);
                poly.setAttribute("points", face.idx.map(i => `${pts[i].px},${pts[i].py}`).join(" "));
                applyFaceStyle(poly);
                g.appendChild(poly);
            });

            // ---------- 7) 绘制边（自动虚实线） ----------
            const edgesDefinitions = [
                [0, 1], [1, 2], [2, 3], [3, 0], // 前圈
                [4, 5], [5, 6], [6, 7], [7, 4], // 后圈
                [0, 4], [1, 5], [2, 6], [3, 7]  // 连接棱
            ];

            edgesDefinitions.forEach((edgeIndices, i) => {
                const [u, v] = edgeIndices;

                // 查找共享此边的面（相邻顶点）
                const sharedFaces = facesTopology.filter(f => {
                    const idxList = f.idx;
                    const posU = idxList.indexOf(u);
                    const posV = idxList.indexOf(v);
                    if (posU === -1 || posV === -1) return false;
                    const len = idxList.length;
                    return (posU === (posV + 1) % len) || (posV === (posU + 1) % len);
                });

                // 任一共享面可见 => 边可见
                const isVisible = sharedFaces.some(f => faceVisibility[f.name]);

                const line = document.createElementNS(SVG_NS, "line");
                line.setAttribute("id", `${id}-edge-${i}`);
                line.setAttribute("x1", pts[u].px);
                line.setAttribute("y1", pts[u].py);
                line.setAttribute("x2", pts[v].px);
                line.setAttribute("y2", pts[v].py);

                if (isVisible) applyVisibleStroke(line);
                else applyHiddenStroke(line);

                g.appendChild(line);
            });

            // ---------- 8) 顶点（可选） ----------
            if (s.showVertices) {
                pts.forEach((p, i) => {
                    const circle = document.createElementNS(SVG_NS, "circle");
                    circle.setAttribute("id", `${id}-vertex-${i}`);
                    circle.setAttribute("cx", p.px);
                    circle.setAttribute("cy", p.py);
                    applyVertexStyle(circle);
                    g.appendChild(circle);
                });
            }

            // ---------- 9) 中心点（可选，带 id） ----------
            if (s.showCenters) {
                const pc = projectFn(x + w/2, y + h/2, z + d/2, config);
                const c = document.createElementNS(SVG_NS, "circle");
                c.setAttribute("id", `${id}-center`);
                c.setAttribute("cx", pc.px);
                c.setAttribute("cy", pc.py);
                c.setAttribute("r", s.centerRadius || 3);
                c.setAttribute("fill", s.centerFill || "#e11d48");
                g.appendChild(c);
            }

            svgTarget.appendChild(g);
            return g;
        }
        /**
         * 绘制圆柱体 (支持自定义投影策略)
         * 
         * @param {Object} config - 配置对象
         * @param {string} config.id - SVG 元素 ID 前缀
         * @param {number} config.x - 底面圆心 x 坐标 (3D)
         * @param {number} config.y - 底面圆心 y 坐标 (3D)
         * @param {number} config.z - 底面圆心 z 坐标 (3D)
         * @param {number} config.r - 圆柱半径
         * @param {number} config.h - 圆柱高度
         * @param {number} config.centerX - 画布中心点 X
         * @param {number} config.centerY - 画布中心点 Y
         * @param {Function} [config.projectFn=Projections.FRONT] - 投影函数（圆柱/圆锥默认 FRONT）
         * @param {Object} [config.styles] - 样式配置
         */
        function drawCylinder(config) {
            const {
                id,
                x, y, z, r, h,
                projectFn = Projections.FRONT,
                styles = {},
            } = config;

            const s = { ...DEFAULT_STYLES, ...styles };
            const segments = (typeof s.segments === "number" && s.segments >= 12) ? s.segments : 72;

            // ---- 样式应用工具：可见/不可见边、面 ----
            const applyVisibleStroke = (el) => {
                el.setAttribute("stroke", s.edgeStroke);
                el.setAttribute("stroke-width", s.edgeWidth);
                if (s.edgeOpacity != null) el.setAttribute("stroke-opacity", s.edgeOpacity);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
            };

            const applyHiddenStroke = (el) => {
                const hs = (s.hiddenStroke != null) ? s.hiddenStroke : s.edgeStroke;
                const hw = (s.hiddenWidth != null) ? s.hiddenWidth : s.edgeWidth;
                const ho = (s.hiddenOpacity != null) ? s.hiddenOpacity : s.edgeOpacity;
                const hd = (s.hiddenDashArray != null) ? s.hiddenDashArray : s.dashArray;

                el.setAttribute("stroke", hs);
                el.setAttribute("stroke-width", hw);
                if (ho != null) el.setAttribute("stroke-opacity", ho);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
                if (hd) el.setAttribute("stroke-dasharray", hd);
            };

            const applyFaceFill = (el) => {
                el.setAttribute("fill", s.faceFill);
                if (s.faceOpacity != null) el.setAttribute("fill-opacity", s.faceOpacity);

                // 面描边（可选）
                if (s.faceStroke && s.faceStroke !== "none" && (s.faceStrokeWidth || 0) > 0) {
                    el.setAttribute("stroke", s.faceStroke);
                    el.setAttribute("stroke-width", s.faceStrokeWidth);
                    if (s.faceStrokeOpacity != null) el.setAttribute("stroke-opacity", s.faceStrokeOpacity);
                    if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                    if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                } else {
                    el.setAttribute("stroke", "none");
                }
            };

            // 1) 生成顶面/底面投影点
            const bottomPts = [];
            const topPts = [];
            for (let i = 0; i < segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                const dx = r * Math.cos(theta);
                const dz = r * Math.sin(theta);
                bottomPts.push(projectFn(x + dx, y,     z + dz, config));
                topPts.push(projectFn(   x + dx, y + h, z + dz, config));
            }

            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // 2) 找轮廓切点：屏幕 X 最小/最大
            let minIdx = 0, maxIdx = 0;
            bottomPts.forEach((p, i) => {
                if (p.px < bottomPts[minIdx].px) minIdx = i;
                if (p.px > bottomPts[maxIdx].px) maxIdx = i;
            });

            // 3) 弧线 path 数据
            const getArcD = (pts, startIdx, endIdx) => {
                let d = `M ${pts[startIdx].px},${pts[startIdx].py}`;
                let i = startIdx;
                while (i !== endIdx) {
                    i = (i + 1) % segments;
                    d += ` L ${pts[i].px},${pts[i].py}`;
                }
                return d;
            };

            // 4) 判断前后弧（通过两段中点 py）
            const midIdxA = Math.floor((minIdx < maxIdx ? (minIdx + maxIdx) : (minIdx + maxIdx + segments)) / 2) % segments;
            const midIdxB = Math.floor((maxIdx < minIdx ? (maxIdx + minIdx) : (maxIdx + minIdx + segments)) / 2) % segments;

            const yA = bottomPts[midIdxA].py;
            const yB = bottomPts[midIdxB].py;

            let frontStart, frontEnd, backStart, backEnd;
            if (yA > yB) {
                frontStart = minIdx; frontEnd = maxIdx;
                backStart = maxIdx;  backEnd = minIdx;
            } else {
                frontStart = maxIdx; frontEnd = minIdx;
                backStart = minIdx;  backEnd = maxIdx;
            }

            // =========================
            // (A) 面：底面/侧面/顶面（补齐 id）
            // =========================

            // A1) 底面 face（补齐：以前没有）——放在最底层
            const bottomFace = document.createElementNS(SVG_NS, "polygon");
            bottomFace.setAttribute("id", `${id}-bottom-face`);
            bottomFace.setAttribute("points", bottomPts.map(p => `${p.px},${p.py}`).join(" "));
            applyFaceFill(bottomFace);
            g.appendChild(bottomFace);

            // A2) 侧面 face（补齐：以前 sidePoly 没 id）
            // 逻辑：沿“底面前弧”走一圈，再沿“顶面前弧”反向回来，形成侧面可见区域
            // if (s.faceFill && s.faceFill !== "none") {
            const sidePolyPoints = [];
            let curr = frontStart;
            while (true) {
                sidePolyPoints.push(bottomPts[curr]);
                if (curr === frontEnd) break;
                curr = (curr + 1) % segments;
            }
            curr = frontEnd;
            while (true) {
                sidePolyPoints.push(topPts[curr]);
                if (curr === frontStart) break;
                curr = (curr - 1 + segments) % segments;
            }

            const sideFace = document.createElementNS(SVG_NS, "polygon");
            sideFace.setAttribute("id", `${id}-side-face`);
            sideFace.setAttribute("points", sidePolyPoints.map(p => `${p.px},${p.py}`).join(" "));
            sideFace.setAttribute("fill", s.faceFill);
            if (s.faceOpacity != null) sideFace.setAttribute("fill-opacity", s.faceOpacity);
            sideFace.setAttribute("stroke", "none");
            g.appendChild(sideFace);
            // }

            // A3) 顶面 face（已有 id：top-face）
            const topFace = document.createElementNS(SVG_NS, "polygon");
            topFace.setAttribute("id", `${id}-top-face`);
            topFace.setAttribute("points", topPts.map(p => `${p.px},${p.py}`).join(" "));
            topFace.setAttribute("fill", s.faceFill);
            if (s.faceOpacity != null) topFace.setAttribute("fill-opacity", s.faceOpacity);

            // 顶面边界通常要显示：这里用可见边样式描边（不依赖 faceStroke）
            topFace.setAttribute("stroke", s.edgeStroke);
            topFace.setAttribute("stroke-width", s.edgeWidth);
            if (s.edgeOpacity != null) topFace.setAttribute("stroke-opacity", s.edgeOpacity);
            if (s.edgeLinecap) topFace.setAttribute("stroke-linecap", s.edgeLinecap);
            if (s.edgeLinejoin) topFace.setAttribute("stroke-linejoin", s.edgeLinejoin);
            g.appendChild(topFace);

            // =========================
            // (B) 边：底面前后弧 + 侧棱
            // =========================

            // B1) 底面后弧（hidden）
            const bottomBack = document.createElementNS(SVG_NS, "path");
            bottomBack.setAttribute("id", `${id}-bottom-back`);
            bottomBack.setAttribute("d", getArcD(bottomPts, backStart, backEnd));
            bottomBack.setAttribute("fill", "none");
            applyHiddenStroke(bottomBack);
            g.appendChild(bottomBack);

            // B2) 底面前弧（visible）
            const bottomFront = document.createElementNS(SVG_NS, "path");
            bottomFront.setAttribute("id", `${id}-bottom-front`);
            bottomFront.setAttribute("d", getArcD(bottomPts, frontStart, frontEnd));
            bottomFront.setAttribute("fill", "none");
            applyVisibleStroke(bottomFront);
            g.appendChild(bottomFront);

            // B3) 侧棱（左右两条）
            [minIdx, maxIdx].forEach((idx, i) => {
                const line = document.createElementNS(SVG_NS, "line");
                line.setAttribute("id", `${id}-side-${i}`);
                line.setAttribute("x1", topPts[idx].px);    line.setAttribute("y1", topPts[idx].py);
                line.setAttribute("x2", bottomPts[idx].px); line.setAttribute("y2", bottomPts[idx].py);
                applyVisibleStroke(line);
                g.appendChild(line);
            });

            // =========================
            // (C) 调试点：中心点（可选）
            // =========================
            if (s.showCenters) {
                const topCenter = projectFn(x, y + h, z, config);
                const bottomCenter = projectFn(x, y, z, config);

                const mk = (pt, cid) => {
                    const c = document.createElementNS(SVG_NS, "circle");
                    c.setAttribute("id", cid);
                    c.setAttribute("cx", pt.px);
                    c.setAttribute("cy", pt.py);
                    c.setAttribute("r", s.centerRadius || 3);
                    c.setAttribute("fill", s.centerFill || "#e11d48");
                    c.setAttribute("opacity", 1);
                    return c;
                };

                g.appendChild(mk(bottomCenter, `${id}-center-bottom`));
                g.appendChild(mk(topCenter, `${id}-center-top`));
            }

            // =========================
            // (D) 顶点（可选）
            // =========================
            if (s.showVertices) {
                // 保留你原来的关键点策略 + 补齐样式字段
                const topCenter = projectFn(x, y + h, z, config);
                const bottomCenter = projectFn(x, y, z, config);

                const keyPoints = [
                    { pt: topCenter, label: "top-center" },
                    { pt: bottomCenter, label: "bottom-center" },
                    { pt: topPts[0], label: "top-0" },
                    { pt: bottomPts[0], label: "bottom-0" }
                ];

                keyPoints.forEach(kp => {
                    const circle = document.createElementNS(SVG_NS, "circle");
                    circle.setAttribute("id", `${id}-vertex-${kp.label}`);
                    circle.setAttribute("cx", kp.pt.px);
                    circle.setAttribute("cy", kp.pt.py);
                    circle.setAttribute("r", s.vertexRadius);
                    circle.setAttribute("fill", s.vertexFill);
                    if (s.vertexOpacity != null) circle.setAttribute("fill-opacity", s.vertexOpacity);

                    if (s.vertexStroke && s.vertexStroke !== "none" && (s.vertexStrokeWidth || 0) > 0) {
                        circle.setAttribute("stroke", s.vertexStroke);
                        circle.setAttribute("stroke-width", s.vertexStrokeWidth);
                    } else {
                        circle.setAttribute("stroke", "none");
                    }
                    g.appendChild(circle);
                });
            }

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawCylinder: global svg not found.");
            svgTarget.appendChild(g);
            return g;
        }
        /**
         * 绘制圆锥体 (支持自定义投影策略)
         * 
         * @param {Object} config - 配置对象
         * @param {string} config.id - SVG 元素 ID 前缀
         * @param {number} config.x - 底面圆心 x 坐标 (3D)
         * @param {number} config.y - 底面圆心 y 坐标 (3D, 高度基准)
         * @param {number} config.z - 底面圆心 z 坐标 (3D, 深度)
         * @param {number} config.r - 底面半径
         * @param {number} config.h - 圆锥高度 (顶点坐标为 y+h)
         * @param {number} config.centerX - 画布中心点 X
         * @param {number} config.centerY - 画布中心点 Y
         * @param {Function} [config.projectFn=Projections.FRONT] - 投影函数（圆柱/圆锥默认 FRONT）
         * @param {Object} [config.styles] - 样式配置 (showVertices, faceFill 等)
         */
        function drawCone(config) {
            const {
                id,
                x, y, z, r, h,
                projectFn = Projections.FRONT,
                styles = {},
            } = config;

            const s = { ...DEFAULT_STYLES, ...styles };
            const segments = (typeof s.segments === "number" && s.segments >= 12) ? s.segments : 72;

            // ---- 样式应用工具：可见/不可见边 ----
            const applyVisibleStroke = (el) => {
                el.setAttribute("stroke", s.edgeStroke);
                el.setAttribute("stroke-width", s.edgeWidth);
                if (s.edgeOpacity != null) el.setAttribute("stroke-opacity", s.edgeOpacity);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
            };

            const applyHiddenStroke = (el) => {
                const hs = (s.hiddenStroke != null) ? s.hiddenStroke : s.edgeStroke;
                const hw = (s.hiddenWidth != null) ? s.hiddenWidth : s.edgeWidth;
                const ho = (s.hiddenOpacity != null) ? s.hiddenOpacity : s.edgeOpacity;
                const hd = (s.hiddenDashArray != null) ? s.hiddenDashArray : s.dashArray;

                el.setAttribute("stroke", hs);
                el.setAttribute("stroke-width", hw);
                if (ho != null) el.setAttribute("stroke-opacity", ho);
                if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                if (s.edgeLinejoin === "miter" && s.edgeMiterlimit != null) {
                    el.setAttribute("stroke-miterlimit", s.edgeMiterlimit);
                }
                if (hd) el.setAttribute("stroke-dasharray", hd);
            };

            const applyFaceFill = (el) => {
                el.setAttribute("fill", s.faceFill);
                if (s.faceOpacity != null) el.setAttribute("fill-opacity", s.faceOpacity);

                if (s.faceStroke && s.faceStroke !== "none" && (s.faceStrokeWidth || 0) > 0) {
                    el.setAttribute("stroke", s.faceStroke);
                    el.setAttribute("stroke-width", s.faceStrokeWidth);
                    if (s.faceStrokeOpacity != null) el.setAttribute("stroke-opacity", s.faceStrokeOpacity);
                    if (s.edgeLinecap) el.setAttribute("stroke-linecap", s.edgeLinecap);
                    if (s.edgeLinejoin) el.setAttribute("stroke-linejoin", s.edgeLinejoin);
                } else {
                    el.setAttribute("stroke", "none");
                }
            };

            // 1) 顶点投影
            const apex = projectFn(x, y + h, z, config);

            // 2) 底面圆周点投影
            const basePts = [];
            for (let i = 0; i < segments; i++) {
                const rad = (i / segments) * Math.PI * 2;
                const dx = r * Math.cos(rad);
                const dz = r * Math.sin(rad);
                basePts.push(projectFn(x + dx, y, z + dz, config));
            }

            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // 3) 找底面轮廓切点（屏幕 X 最小/最大）
            let minIdx = 0, maxIdx = 0;
            basePts.forEach((p, i) => {
                if (p.px < basePts[minIdx].px) minIdx = i;
                if (p.px > basePts[maxIdx].px) maxIdx = i;
            });

            // 4) 弧线 d
            const getArcD = (start, end) => {
                let d = `M ${basePts[start].px},${basePts[start].py}`;
                let i = start;
                while (i !== end) {
                    i = (i + 1) % segments;
                    d += ` L ${basePts[i].px},${basePts[i].py}`;
                }
                return d;
            };

            // 5) 分前后弧（比较两段中点 py）
            const midA = Math.floor((minIdx < maxIdx ? minIdx + maxIdx : minIdx + maxIdx + segments) / 2) % segments;
            const midB = Math.floor((maxIdx < minIdx ? maxIdx + minIdx : maxIdx + minIdx + segments) / 2) % segments;

            let frontStart, frontEnd, backStart, backEnd;
            if (basePts[midA].py > basePts[midB].py) {
                frontStart = minIdx; frontEnd = maxIdx;
                backStart = maxIdx;  backEnd = minIdx;
            } else {
                frontStart = maxIdx; frontEnd = minIdx;
                backStart = minIdx;  backEnd = maxIdx;
            }

            // =========================
            // (A) 面：底面 + 主体（补齐 id）
            // =========================

            // A1) 底面 face（补齐：圆锥底面）
            const baseFace = document.createElementNS(SVG_NS, "polygon");
            baseFace.setAttribute("id", `${id}-base-face`);
            baseFace.setAttribute("points", basePts.map(p => `${p.px},${p.py}`).join(" "));
            applyFaceFill(baseFace);
            g.appendChild(baseFace);

            // A2) 主体 fill（补齐：以前没有 id）
            if (s.faceFill && s.faceFill !== "none") {
                const polyPts = [apex];
                let curr = frontStart;
                while (true) {
                    polyPts.push(basePts[curr]);
                    if (curr === frontEnd) break;
                    curr = (curr + 1) % segments;
                }

                const bodyFace = document.createElementNS(SVG_NS, "polygon");
                bodyFace.setAttribute("id", `${id}-body-face`);
                bodyFace.setAttribute("points", polyPts.map(p => `${p.px},${p.py}`).join(" "));
                bodyFace.setAttribute("fill", s.faceFill);
                if (s.faceOpacity != null) bodyFace.setAttribute("fill-opacity", s.faceOpacity);
                bodyFace.setAttribute("stroke", "none");
                g.appendChild(bodyFace);
            }

            // =========================
            // (B) 边：底面后弧/前弧 + 两条母线
            // =========================

            // B1) 底面后弧（hidden）
            const backPath = document.createElementNS(SVG_NS, "path");
            backPath.setAttribute("id", `${id}-base-back`);
            backPath.setAttribute("d", getArcD(backStart, backEnd));
            backPath.setAttribute("fill", "none");
            applyHiddenStroke(backPath);
            g.appendChild(backPath);

            // B2) 底面前弧（visible）
            const frontPath = document.createElementNS(SVG_NS, "path");
            frontPath.setAttribute("id", `${id}-base-front`);
            frontPath.setAttribute("d", getArcD(frontStart, frontEnd));
            frontPath.setAttribute("fill", "none");
            applyVisibleStroke(frontPath);
            g.appendChild(frontPath);

            // B3) 两条侧面轮廓线（母线）
            [minIdx, maxIdx].forEach((idx, i) => {
                const line = document.createElementNS(SVG_NS, "line");
                line.setAttribute("id", `${id}-side-${i}`);
                line.setAttribute("x1", apex.px);        line.setAttribute("y1", apex.py);
                line.setAttribute("x2", basePts[idx].px); line.setAttribute("y2", basePts[idx].py);
                applyVisibleStroke(line);
                g.appendChild(line);
            });

            // =========================
            // (C) 顶点/中心轴/中心点（可选）——补齐 axis id
            // =========================
            if (s.showVertices) {
                const baseCenter = projectFn(x, y, z, config);

                const vertices = [
                    { p: apex, id: "apex" },
                    { p: baseCenter, id: "center" },
                    { p: basePts[frontStart], id: "tan1" },
                    { p: basePts[frontEnd], id: "tan2" }
                ];

                vertices.forEach(v => {
                    const circle = document.createElementNS(SVG_NS, "circle");
                    circle.setAttribute("id", `${id}-v-${v.id}`);
                    circle.setAttribute("cx", v.p.px);
                    circle.setAttribute("cy", v.p.py);
                    circle.setAttribute("r", s.vertexRadius);
                    circle.setAttribute("fill", s.vertexFill);
                    if (s.vertexOpacity != null) circle.setAttribute("fill-opacity", s.vertexOpacity);

                    if (s.vertexStroke && s.vertexStroke !== "none" && (s.vertexStrokeWidth || 0) > 0) {
                        circle.setAttribute("stroke", s.vertexStroke);
                        circle.setAttribute("stroke-width", s.vertexStrokeWidth);
                    } else {
                        circle.setAttribute("stroke", "none");
                    }
                    g.appendChild(circle);
                });

                // 中心轴线（补齐 id：axis）
                const axis = document.createElementNS(SVG_NS, "line");
                axis.setAttribute("id", `${id}-axis`);
                axis.setAttribute("x1", baseCenter.px); axis.setAttribute("y1", baseCenter.py);
                axis.setAttribute("x2", apex.px);       axis.setAttribute("y2", apex.py);
                axis.setAttribute("fill", "none");
                applyHiddenStroke(axis);
                // 轴线通常更细一点：不破坏你的默认值，这里仅在未显式设置 hiddenWidth 时做轻微收敛
                if (s.hiddenWidth == null) axis.setAttribute("stroke-width", 1);
                // 轴线 dash 建议更密一些（若你想完全跟 hiddenDashArray 走，可删掉这两行）
                // axis.setAttribute("stroke-dasharray", "3,3");
                g.appendChild(axis);
            }

            // showCenters：给圆锥也加中心点（可选）
            if (s.showCenters) {
                const baseCenter = projectFn(x, y, z, config);

                const mk = (pt, cid) => {
                    const c = document.createElementNS(SVG_NS, "circle");
                    c.setAttribute("id", cid);
                    c.setAttribute("cx", pt.px);
                    c.setAttribute("cy", pt.py);
                    c.setAttribute("r", s.centerRadius || 3);
                    c.setAttribute("fill", s.centerFill || "#e11d48");
                    c.setAttribute("opacity", 1);
                    return c;
                };

                g.appendChild(mk(baseCenter, `${id}-center-base`));
                g.appendChild(mk(apex, `${id}-center-apex`));
            }

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawCone: global svg not found.");
            svgTarget.appendChild(g);
            return g;
        }
        /**
         * 绘制箭头（线段 + 三角箭头）
         * - 直接使用全局 svg（fallback window.mainSvg）
         * - 默认样式来自 DEFAULT_ANNOTATION_STYLES，可用 config.styles 覆盖
         * - 补齐 id：`${id}-shaft`、`${id}-head`
         *
         * @param {Object} config
         * @param {string} config.id - 唯一标识前缀
         * @param {number} config.x1,y1 - 起点
         * @param {number} config.x2,y2 - 终点（箭尖）
         * @param {number} [config.headLength] - 箭头长度（默认用 DEFAULT_ANNOTATION_STYLES.arrowSize 或 15）
         * @param {number} [config.headWidth] - 箭头底边宽（默认用 DEFAULT_ANNOTATION_STYLES.arrowWidth*2 或 10）
         * @param {Object} [config.styles] - 样式覆盖（基于 DEFAULT_ANNOTATION_STYLES）
         */
        function drawArrow(config) {
            const {
                id = "arrow",
                x1 = 100, y1 = 100,
                x2 = 300, y2 = 100,
                headLength,
                headWidth,
                styles = {}
            } = config;

            const s = { ...DEFAULT_ANNOTATION_STYLES, ...styles };

            // ---- 几何 ----
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length < 0.001) return null;

            const ux = dx / length;
            const uy = dy / length;

            // 默认 head 参数：优先使用 config，其次用 DEFAULT_ANNOTATION_STYLES
            const HL = (headLength != null) ? headLength : (s.arrowSize != null ? s.arrowSize : 15);
            const HW = (headWidth  != null) ? headWidth  : (s.arrowWidth != null ? (s.arrowWidth * 2) : 10);

            // 箭尖后退中心点
            const backCX = x2 - HL * ux;
            const backCY = y2 - HL * uy;

            // 垂直向量（用于底边宽）
            const vx = -uy;
            const vy = ux;

            const pLeftX = backCX + (HW / 2) * vx;
            const pLeftY = backCY + (HW / 2) * vy;

            const pRightX = backCX - (HW / 2) * vx;
            const pRightY = backCY - (HW / 2) * vy;

            const headPoints = `${x2},${y2} ${pLeftX},${pLeftY} ${pRightX},${pRightY}`;

            // ---- 组 ----
            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // ---- 箭身 ----
            const shaft = document.createElementNS(SVG_NS, "line");
            shaft.setAttribute("id", `${id}-shaft`);
            shaft.setAttribute("x1", x1);
            shaft.setAttribute("y1", y1);
            shaft.setAttribute("x2", backCX);
            shaft.setAttribute("y2", backCY);

            shaft.setAttribute("stroke", s.stroke);
            shaft.setAttribute("stroke-width", s.strokeWidth);
            if (s.opacity != null) shaft.setAttribute("stroke-opacity", s.opacity);
            if (s.linecap) shaft.setAttribute("stroke-linecap", s.linecap);
            if (s.linejoin) shaft.setAttribute("stroke-linejoin", s.linejoin);

            // dashArray：用于“箭身是否虚线”
            // if (s.dashArray) shaft.setAttribute("stroke-dasharray", s.dashArray);

            g.appendChild(shaft);

            // ---- 箭头 ----
            const head = document.createElementNS(SVG_NS, "polygon");
            head.setAttribute("id", `${id}-head`);
            head.setAttribute("points", headPoints);

            // head 填充：用 s.fill；描边沿用 s.stroke（更统一）
            head.setAttribute("fill", s.fill);
            head.setAttribute("stroke", s.stroke);
            head.setAttribute("stroke-width", Math.max(1, (s.strokeWidth || 1) * 0.6));
            if (s.opacity != null) {
                head.setAttribute("fill-opacity", s.opacity);
                head.setAttribute("stroke-opacity", s.opacity);
            }
            if (s.linejoin) head.setAttribute("stroke-linejoin", s.linejoin);

            g.appendChild(head);

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawArrow: global svg not found.");
            svgTarget.appendChild(g);
            return g;
        }
        /**
         * [通用工具] 绘制工程制图风格的尺寸标注
         * 
         * 功能特性：
         * 1. 支持 3D 坐标自动投影（依赖 Projections 配置）。
         * 2. "工"字形样式：
         *    - 延伸线 (Extension Lines): 垂直于测量向量。
         *    - 主尺寸线 (Dimension Line): 平行于测量向量，且包含箭头。
         * 3. 几何细节控制 (通过 styles 配置):
         *    - gap: 延伸线起始点距离测量点的间隙。
         *    - ext_length: 延伸线的总长度（代码逻辑中，主尺寸线位于延伸线的中点）。
         * 4. 文本自动对齐：
         *    - 根据法向量方向自动判断文本对齐方式 (start/middle/end)，避免文本与线条重叠。
         *    - 包含白色描边 (Halo) 以增强对比度。
         *
         * @param {object} config - 配置对象
         * @param {string} config.id - SVG组ID
         * @param {object} config.p1 - 起始点 3D坐标 {x,y,z}
         * @param {object} config.p2 - 结束点 3D坐标 {x,y,z}
         * @param {number} config.centerX - 画布中心点 X
         * @param {number} config.centerY - 画布中心点 Y
         * @param {string} config.direction - "上" | "下" | "左" | "右"
         * @param {string} config.text - 标注文本
         * @param {function} [config.projectFn] - 投影函数 (默认 Projections.OBLIQUE)
         * @param {object} [config.styles] - 样式覆盖 { gap, ext_length, arrowSize, ... }
         */
        function drawDimensionLabel(config) {
            const {
                id,
                p1,
                p2,
                direction,
                text,
                projectFn = Projections.OBLIQUE,
                styles = {}
            } = config;

            const s = { ...DEFAULT_ANNOTATION_STYLES, ...styles };

            // 直接使用全局 svg（你模板里 const svg = ...），否则 fallback 到 window.mainSvg
            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawDimensionLabel: global svg not found.");

            // 1) 投影
            const pt1 = projectFn(p1.x, p1.y, p1.z, config);
            const pt2 = projectFn(p2.x, p2.y, p2.z, config);

            // 2) 向量
            const dx = pt2.px - pt1.px;
            const dy = pt2.py - pt1.py;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 0.001) return null;

            const ux = dx / len;
            const uy = dy / len;
            const baseNx = -uy;
            const baseNy = ux;

            // 3) 方向枚举 -> dirSign
            const dirVectors = {
                "上": { x: 0,  y: -1 },
                "下": { x: 0,  y:  1 },
                "左": { x: -1, y:  0 },
                "右": { x: 1,  y:  0 }
            };
            const target = dirVectors[direction] || dirVectors["上"];
            const dot = baseNx * target.x + baseNy * target.y;
            const dirSign = dot >= 0 ? 1 : -1;

            const nx = baseNx * dirSign;
            const ny = baseNy * dirSign;

            // 4) 几何点
            const gap = s.gap ?? 15;
            const extLen = s.ext_length ?? 10;

            const dimP1 = {
                x: pt1.px + nx * (gap + extLen / 2),
                y: pt1.py + ny * (gap + extLen / 2)
            };
            const dimP2 = {
                x: pt2.px + nx * (gap + extLen / 2),
                y: pt2.py + ny * (gap + extLen / 2)
            };

            const ext1_Start = { x: pt1.px + nx * gap, y: pt1.py + ny * gap };
            const ext1_End   = { x: pt1.px + nx * (gap + extLen), y: pt1.py + ny * (gap + extLen) };
            const ext2_Start = { x: pt2.px + nx * gap, y: pt2.py + ny * gap };
            const ext2_End   = { x: pt2.px + nx * (gap + extLen), y: pt2.py + ny * (gap + extLen) };

            // 5) 组
            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);
            // 给整个组加个特殊类，避让计算时忽略自己组内的线条¶
            g.setAttribute("class", "annotation-group");

            const applyStroke = (el) => {
                el.setAttribute("stroke", s.stroke);
                el.setAttribute("stroke-width", s.strokeWidth);
                if (s.opacity != null) el.setAttribute("stroke-opacity", s.opacity);
                if (s.linecap) el.setAttribute("stroke-linecap", s.linecap);
                if (s.linejoin) el.setAttribute("stroke-linejoin", s.linejoin);
                if (s.dashArray) el.setAttribute("stroke-dasharray", s.dashArray);
            };

            // 6) 延伸线
            const elExt = document.createElementNS(SVG_NS, "path");
            elExt.setAttribute("id", `${id}-ext`);
            elExt.setAttribute(
                "d",
                `M ${ext1_Start.x},${ext1_Start.y} L ${ext1_End.x},${ext1_End.y} ` +
                `M ${ext2_Start.x},${ext2_Start.y} L ${ext2_End.x},${ext2_End.y}`
            );
            elExt.setAttribute("fill", "none");
            applyStroke(elExt);
            g.appendChild(elExt);

            // 7) 主尺寸线
            const elDim = document.createElementNS(SVG_NS, "line");
            elDim.setAttribute("id", `${id}-dim`);
            elDim.setAttribute("x1", dimP1.x);
            elDim.setAttribute("y1", dimP1.y);
            elDim.setAttribute("x2", dimP2.x);
            elDim.setAttribute("y2", dimP2.y);
            applyStroke(elDim);
            g.appendChild(elDim);

            // 8) 双箭头
            const arrowSize = s.arrowSize ?? 8;
            const arrowWidth = s.arrowWidth ?? 3;

            const a1Tip = dimP1;
            const a1Base = { x: dimP1.x + ux * arrowSize, y: dimP1.y + uy * arrowSize };
            const a1Left = { x: a1Base.x + nx * arrowWidth, y: a1Base.y + ny * arrowWidth };
            const a1Right= { x: a1Base.x - nx * arrowWidth, y: a1Base.y - ny * arrowWidth };

            const a2Tip = dimP2;
            const a2Base = { x: dimP2.x - ux * arrowSize, y: dimP2.y - uy * arrowSize };
            const a2Left = { x: a2Base.x + nx * arrowWidth, y: a2Base.y + ny * arrowWidth };
            const a2Right= { x: a2Base.x - nx * arrowWidth, y: a2Base.y - ny * arrowWidth };

            const elArrows = document.createElementNS(SVG_NS, "path");
            elArrows.setAttribute("id", `${id}-arrows`);
            elArrows.setAttribute(
                "d",
                `M ${a1Tip.x},${a1Tip.y} L ${a1Left.x},${a1Left.y} L ${a1Right.x},${a1Right.y} Z ` +
                `M ${a2Tip.x},${a2Tip.y} L ${a2Left.x},${a2Left.y} L ${a2Right.x},${a2Right.y} Z`
            );
            elArrows.setAttribute("fill", s.fill);
            if (s.opacity != null) elArrows.setAttribute("fill-opacity", s.opacity);
            g.appendChild(elArrows);

            // 9) 文本（动态 anchor）
            const midX = (dimP1.x + dimP2.x) / 2;
            const midY = (dimP1.y + dimP2.y) / 2;
            const textOffset = s.textOffset ?? 13;

            const textX = midX + nx * textOffset;
            const textY = midY + ny * textOffset;

            let anchor = "middle";
            if (nx > 0.3) anchor = "start";
            else if (nx < -0.3) anchor = "end";

            const elText = document.createElementNS(SVG_NS, "text");
            elText.setAttribute("id", `${id}-text`);
            elText.setAttribute("x", textX);
            elText.setAttribute("y", textY);
            elText.setAttribute("text-anchor", anchor);
            elText.setAttribute("dominant-baseline", "middle");
            elText.setAttribute("font-size", s.fontSize);
            elText.setAttribute("font-family", s.fontFamily);
            elText.setAttribute("fill", s.textFill ?? s.fill);

            // Halo
            elText.setAttribute("stroke", s.haloStroke);
            elText.setAttribute("stroke-width", s.haloWidth);
            elText.setAttribute("paint-order", "stroke");
            elText.setAttribute("stroke-linejoin", s.haloLinejoin || "round");

            elText.textContent = text;

            elText.classList.add("smart-label"); // 标记它是智能标签
            elText.dataset.nx = nx;
            elText.dataset.ny = ny;
            elText.dataset.ux = ux;
            elText.dataset.uy = uy;
            elText.dataset.ox = textX;           // 初始位置 X
            elText.dataset.oy = textY;           // 初始位置 Y
            elText.dataset.limit = (len / 2) - (s.arrowSize || 8) - 5; 
            elText.dataset.parentId = id;        // 归属组 ID

            g.appendChild(elText);

            // 先挂到 svg，bbox 才可信
            svgTarget.appendChild(g);

            // 可选文字背景 rect
            if (s.textBackground) {
                const bb = elText.getBBox();
                const pad = s.textBgPadding ?? 3;
                const bg = document.createElementNS(SVG_NS, "rect");
                bg.setAttribute("id", `${id}-text-bg`);
                bg.setAttribute("x", bb.x - pad);
                bg.setAttribute("y", bb.y - pad);
                bg.setAttribute("width", bb.width + pad * 2);
                bg.setAttribute("height", bb.height + pad * 2);
                bg.setAttribute("rx", 2);
                bg.setAttribute("ry", 2);
                bg.setAttribute("fill", s.textBgFill ?? "white");
                bg.setAttribute("fill-opacity", s.textBgOpacity ?? 1);
                bg.setAttribute("stroke", "none");
                g.insertBefore(bg, elText);
            }

            return g;
        }
        /**
        * [Type 2] 绘制花括号标记
        * 适用场景：汇总多段尺寸、总览标注
        */
        function drawCurlyBraceLabel(config) {
            const {
                id,
                p1,
                p2,
                text,
                direction,
                projectFn = Projections.OBLIQUE,
                styles = {}
            } = config;

            const s = { ...DEFAULT_ANNOTATION_STYLES, ...styles };

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawCurlyBraceLabel: global svg not found.");

            // 1) 投影
            const pt1 = projectFn(p1.x, p1.y, p1.z, config);
            const pt2 = projectFn(p2.x, p2.y, p2.z, config);

            // 2) 轴向 u
            const dx = pt2.px - pt1.px;
            const dy = pt2.py - pt1.py;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 0.001) return null;

            const ux = dx / len;
            const uy = dy / len;

            // 3) 法向 n（带方向）
            const baseNx = -uy;
            const baseNy = ux;

            const dirVectors = {
                "上": { x: 0,  y: -1 },
                "下": { x: 0,  y:  1 },
                "左": { x: -1, y:  0 },
                "右": { x: 1,  y:  0 }
            };
            const target = dirVectors[direction] || dirVectors["上"];
            const dot = baseNx * target.x + baseNy * target.y;
            const dirSign = dot >= 0 ? 1 : -1;

            const nx = baseNx * dirSign;
            const ny = baseNy * dirSign;

            // 4) 参数
            const braceGap = s.braceGap ?? 15;
            let depth = s.braceDepth ?? 10;
            let q = depth * 0.5;

            // 线太短防打结
            if (q * 4 > len) {
                q = len / 4;
                depth = q * 2;
            }

            // 5) 脚点（应用 gap）
            const pStart = { x: pt1.px + nx * braceGap, y: pt1.py + ny * braceGap };
            const pEnd   = { x: pt2.px + nx * braceGap, y: pt2.py + ny * braceGap };

            const midX = (pStart.x + pEnd.x) / 2;
            const midY = (pStart.y + pEnd.y) / 2;

            const tip = { x: midX + nx * depth, y: midY + ny * depth };

            const getPt = (baseX, baseY, uOff, nOff) => ({
                x: baseX + ux * uOff + nx * nOff,
                y: baseY + uy * uOff + ny * nOff
            });

            const pCorner1_Ctrl = getPt(pStart.x, pStart.y, 0, q);
            const pCorner1_End  = getPt(pStart.x, pStart.y, q, q);

            const pTip_Start    = getPt(midX, midY, -q, q);
            const pTip_Ctrl     = getPt(midX, midY, 0, q);

            const pTip_End      = getPt(midX, midY, q, q);
            const pCorner2_Start= getPt(pEnd.x, pEnd.y, -q, q);
            const pCorner2_Ctrl = getPt(pEnd.x, pEnd.y, 0, q);

            const pathData =
                `M ${pStart.x},${pStart.y} ` +
                `Q ${pCorner1_Ctrl.x},${pCorner1_Ctrl.y} ${pCorner1_End.x},${pCorner1_End.y} ` +
                `L ${pTip_Start.x},${pTip_Start.y} ` +
                `Q ${pTip_Ctrl.x},${pTip_Ctrl.y} ${tip.x},${tip.y} ` +
                `Q ${pTip_Ctrl.x},${pTip_Ctrl.y} ${pTip_End.x},${pTip_End.y} ` +
                `L ${pCorner2_Start.x},${pCorner2_Start.y} ` +
                `Q ${pCorner2_Ctrl.x},${pCorner2_Ctrl.y} ${pEnd.x},${pEnd.y}`;

            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // 括号路径
            const elPath = document.createElementNS(SVG_NS, "path");
            elPath.setAttribute("id", `${id}-brace`);
            elPath.setAttribute("d", pathData);
            elPath.setAttribute("fill", "none");
            elPath.setAttribute("stroke", s.stroke);
            elPath.setAttribute("stroke-width", s.strokeWidth);
            if (s.opacity != null) elPath.setAttribute("stroke-opacity", s.opacity);
            if (s.linecap) elPath.setAttribute("stroke-linecap", s.linecap);
            if (s.linejoin) elPath.setAttribute("stroke-linejoin", s.linejoin);
            if (s.dashArray) elPath.setAttribute("stroke-dasharray", s.dashArray);
            g.appendChild(elPath);

            // 文本
            const textOffset = s.textOffset ?? 13;
            const textX = tip.x + nx * textOffset;
            const textY = tip.y + ny * textOffset;

            let anchor = "middle";
            if (Math.abs(nx) > Math.abs(ny)) anchor = nx > 0 ? "start" : "end";

            const elText = document.createElementNS(SVG_NS, "text");
            elText.setAttribute("id", `${id}-text`);
            elText.setAttribute("x", textX);
            elText.setAttribute("y", textY);
            elText.setAttribute("text-anchor", anchor);
            elText.setAttribute("dominant-baseline", "middle");
            elText.setAttribute("font-size", s.fontSize);
            elText.setAttribute("font-family", s.fontFamily);
            elText.setAttribute("fill", s.textFill ?? s.fill);

            elText.setAttribute("stroke", s.haloStroke);
            elText.setAttribute("stroke-width", s.haloWidth);
            elText.setAttribute("paint-order", "stroke");
            elText.setAttribute("stroke-linejoin", s.haloLinejoin || "round");

            elText.textContent = text;
            g.appendChild(elText);

            svgTarget.appendChild(g);

            // 可选文字背景
            if (s.textBackground) {
                const bb = elText.getBBox();
                const pad = s.textBgPadding ?? 3;
                const bg = document.createElementNS(SVG_NS, "rect");
                bg.setAttribute("id", `${id}-text-bg`);
                bg.setAttribute("x", bb.x - pad);
                bg.setAttribute("y", bb.y - pad);
                bg.setAttribute("width", bb.width + pad * 2);
                bg.setAttribute("height", bb.height + pad * 2);
                bg.setAttribute("rx", 2);
                bg.setAttribute("ry", 2);
                bg.setAttribute("fill", s.textBgFill ?? "white");
                bg.setAttribute("fill-opacity", s.textBgOpacity ?? 1);
                bg.setAttribute("stroke", "none");
                g.insertBefore(bg, elText);
            }

            return g;
        }
        /**
         * [Type 3] 绘制原地/辅助线标记
         * 适用场景：半径(R)、直径(Φ)、内部高、辅助虚线
         */
        function drawDirectLabel(config) {
            const {
                id,
                p1,
                p2,
                text,
                projectFn = Projections.OBLIQUE,
                styles = {}
            } = config;

            const s = { ...DEFAULT_ANNOTATION_STYLES, ...styles };

            const svgTarget = (typeof svg !== "undefined" ? svg : window.mainSvg);
            if (!svgTarget) throw new Error("drawDirectLabel: global svg not found.");

            const pt1 = projectFn(p1.x, p1.y, p1.z, config);
            const pt2 = projectFn(p2.x, p2.y, p2.z, config);

            const dx = pt2.px - pt1.px;
            const dy = pt2.py - pt1.py;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 0.001) return null;

            const ux = dx / len;
            const uy = dy / len;

            // 法向（用于箭头展开）
            const nx = -uy;
            const ny = ux;

            const g = document.createElementNS(SVG_NS, "g");
            g.setAttribute("id", id);

            // 1) 连接线
            const line = document.createElementNS(SVG_NS, "line");
            line.setAttribute("id", `${id}-line`);
            line.setAttribute("x1", pt1.px);
            line.setAttribute("y1", pt1.py);
            line.setAttribute("x2", pt2.px);
            line.setAttribute("y2", pt2.py);
            line.setAttribute("stroke", s.stroke);
            line.setAttribute("stroke-width", s.strokeWidth);
            if (s.opacity != null) line.setAttribute("stroke-opacity", s.opacity);
            if (s.linecap) line.setAttribute("stroke-linecap", s.linecap);
            if (s.linejoin) line.setAttribute("stroke-linejoin", s.linejoin);

            // direct 默认虚线：优先 directDashArray，其次 dashArray
            const dash = (s.directDashArray != null) ? s.directDashArray : s.dashArray;
            if (dash) line.setAttribute("stroke-dasharray", dash);

            g.appendChild(line);

            // 2) 箭头（可选）
            // const arrowSize = s.arrowSize ?? 6;
            // const fat = arrowSize * 0.4;

            // const mkArrow = (tipX, tipY, dirUx, dirUy, arrowId) => {
            //     const baseX = tipX - dirUx * arrowSize;
            //     const baseY = tipY - dirUy * arrowSize;

            //     const leftX  = baseX + nx * fat;
            //     const leftY  = baseY + ny * fat;
            //     const rightX = baseX - nx * fat;
            //     const rightY = baseY - ny * fat;

            //     const p = document.createElementNS(SVG_NS, "path");
            //     p.setAttribute("id", arrowId);
            //     p.setAttribute("d", `M ${tipX},${tipY} L ${leftX},${leftY} L ${rightX},${rightY} Z`);
            //     // p.setAttribute("fill", s.stroke);
            //     p.setAttribute("fill", s.fill);
            //     if (s.opacity != null) p.setAttribute("fill-opacity", s.opacity);
            //     return p;
            // };

            // const arrowStart = (s.directArrowStart != null) ? s.directArrowStart : true;
            // const arrowEnd   = (s.directArrowEnd != null) ? s.directArrowEnd : true;

            // if (arrowStart) g.appendChild(mkArrow(pt1.px, pt1.py, -ux, -uy, `${id}-arrow-start`));
            // if (arrowEnd)   g.appendChild(mkArrow(pt2.px, pt2.py,  ux,  uy, `${id}-arrow-end`));

            // 3) 文本（居中）
            const midX = (pt1.px + pt2.px) / 2;
            const midY = (pt1.py + pt2.py) / 2;

            const elText = document.createElementNS(SVG_NS, "text");
            elText.setAttribute("id", `${id}-text`);
            elText.setAttribute("x", midX);
            elText.setAttribute("y", midY);
            elText.setAttribute("text-anchor", "middle");
            elText.setAttribute("dominant-baseline", "middle");
            elText.setAttribute("font-size", s.fontSize);
            elText.setAttribute("font-family", s.fontFamily);
            elText.setAttribute("fill", s.textFill ?? s.fill);

            // Halo（direct 更强一点）
            elText.setAttribute("stroke", s.haloStroke);
            elText.setAttribute("stroke-width", Math.max(s.haloWidth ?? 3, 4));
            elText.setAttribute("paint-order", "stroke");
            elText.setAttribute("stroke-linejoin", s.haloLinejoin || "round");

            elText.textContent = text;
            g.appendChild(elText);

            svgTarget.appendChild(g);

            // 可选文字背景
            if (s.textBackground) {
                const bb = elText.getBBox();
                const pad = s.textBgPadding ?? 3;
                const bg = document.createElementNS(SVG_NS, "rect");
                bg.setAttribute("id", `${id}-text-bg`);
                bg.setAttribute("x", bb.x - pad);
                bg.setAttribute("y", bb.y - pad);
                bg.setAttribute("width", bb.width + pad * 2);
                bg.setAttribute("height", bb.height + pad * 2);
                bg.setAttribute("rx", 2);
                bg.setAttribute("ry", 2);
                bg.setAttribute("fill", s.textBgFill ?? "white");
                bg.setAttribute("fill-opacity", s.textBgOpacity ?? 1);
                bg.setAttribute("stroke", "none");
                g.insertBefore(bg, elText);
            }

            return g;
        }
        
        /**
         * 全局函数：自动调整带有 .smart-label 类的文本位置，使其不遮挡几何图形。
         * 
         * 原理：
         * 1. 找到所有几何图形（path, line, polygon, rect）。
         * 2. 遍历所有智能标签。
         * 3. 检测标签与几何图形是否重叠。
         * 4. 如果重叠，分别模拟“法向”、“切向+”、“切向-”三个方向，谁先找到空位且移动距离最短，就选谁。
         * 5. 重复尝试，直到不重叠或达到最大尝试次数。
         * 
         * @param {SVGElement} svgRoot - 根 SVG 元素
         */
        function autoAvoidOverlap(svgRoot) {
            if (!svgRoot) svgRoot = window.mainSvg;
            
            // 1. 获取障碍物和标签
            const allShapes = Array.from(svgRoot.querySelectorAll("path, polygon, line, rect, circle, text"));
            const labels = Array.from(svgRoot.querySelectorAll(".smart-label"));

            // 配置
            const MAX_STEPS = 20;    // 增加尝试次数
            const STEP_SIZE = 4;     // 步长
            const PADDING = 2;       // 碰撞缓冲
            const TANGENT_PENALTY = 1.2; // 切向移动的“惩罚系数”。1.2表示：切向移动10px的代价 等于 法向移动12px。
                                        // 这会让算法在两者距离差不多时，优先选择法向（保持居中）。

            // 碰撞检测辅助函数
            const checkCollision = (rect, ignoreGroup) => {
                for (let shape of allShapes) {
                    // 排除自身和同组元素
                    if (ignoreGroup && ignoreGroup.contains(shape)) continue;
                    // 排除不可见元素
                    const style = window.getComputedStyle(shape);
                    if (style.display === "none" || style.opacity === "0" || style.visibility === "hidden") continue;
                    if (shape.classList.contains("smart-label")) continue; // 暂不考虑标签互撞，简化计算
                    if (shape.id && shape.id.includes("text-bg")) continue;

                    const shapeRect = shape.getBBox();
                    if (!(rect.x > shapeRect.x + shapeRect.width - PADDING || 
                        rect.x + rect.width < shapeRect.x + PADDING || 
                        rect.y > shapeRect.y + shapeRect.height - PADDING || 
                        rect.y + rect.height < shapeRect.y + PADDING)) {
                        return true; // 撞了
                    }
                }
                return false; // 没撞
            };

            labels.forEach(textEl => {
                const nx = parseFloat(textEl.dataset.nx);
                const ny = parseFloat(textEl.dataset.ny);
                const ux = parseFloat(textEl.dataset.ux);
                const uy = parseFloat(textEl.dataset.uy);
                const ox = parseFloat(textEl.dataset.ox);
                const oy = parseFloat(textEl.dataset.oy);
                const limit = parseFloat(textEl.dataset.limit);
                const parentId = textEl.dataset.parentId;
                const myGroup = document.getElementById(parentId);

                // 获取原始 BBox 尺寸 (宽和高)
                // 注意：这里需要先把文字重置回原点测一下尺寸，因为 getBBox 是基于当前属性的
                textEl.setAttribute("x", ox);
                textEl.setAttribute("y", oy);
                const baseBox = textEl.getBBox();
                const w = baseBox.width;
                const h = baseBox.height;

                // 定义模拟函数：返回找到安全位置所需的 [步数, 最终x, 最终y]
                // vecX, vecY: 移动方向向量
                // maxDist: 最大移动距离限制 (切向有限制，法向通常无限)
                const findSafePos = (vecX, vecY, maxDist) => {
                    for (let i = 0; i <= MAX_STEPS; i++) {
                        const dist = i * STEP_SIZE;
                        if (maxDist !== null && dist > maxDist) return null; // 超过限制，此路不通

                        const tryX = ox + vecX * dist;
                        const tryY = oy + vecY * dist;

                        // 构造虚拟 Rect 进行检测，不操作 DOM，性能更好
                        // 注意：text 的 x,y 通常是中点(middle)或基线，需要根据 anchor 修正 rect 左上角
                        // 这里简化假设：drawDimensionLabel 用的是 middle，所以 x 是中心，y 是中心
                        const virtualRect = {
                            x: tryX - w / 2, // 居中修正
                            y: tryY - h / 2, // 居中修正
                            width: w,
                            height: h
                        };

                        if (!checkCollision(virtualRect, myGroup)) {
                            return { steps: i, x: tryX, y: tryY };
                        }
                    }
                    return null; // 尝试完步数还没找到
                };

                // --- 开始三路探测 ---

                // 1. 法向探测 (Normal)
                const resNormal = findSafePos(nx, ny, null);

                // 2. 切向正向探测 (Tangent +)
                const resTanPos = findSafePos(ux, uy, limit);

                // 3. 切向负向探测 (Tangent -)
                const resTanNeg = findSafePos(-ux, -uy, limit);

                // --- 评分与决策 ---
                
                // 计算代价 (Cost) = 步数 * 惩罚系数
                // 如果没找到(null)，代价为无穷大
                const costNormal = resNormal ? resNormal.steps : Infinity;
                const costTanPos = resTanPos ? resTanPos.steps * TANGENT_PENALTY : Infinity;
                const costTanNeg = resTanNeg ? resTanNeg.steps * TANGENT_PENALTY : Infinity;

                // 找出最小代价
                const minCost = Math.min(costNormal, costTanPos, costTanNeg);

                if (minCost === Infinity) {
                    // 三个方向都堵死了（或者步数不够），那就不动，或者默认保留法向最后一次尝试
                    // 这里选择保持原位
                    return; 
                }

                // 应用最佳位置
                let bestPos = null;
                if (minCost === costNormal) bestPos = resNormal;
                else if (minCost === costTanPos) bestPos = resTanPos;
                else bestPos = resTanNeg;

                // 只有当需要移动时才修改 DOM
                if (bestPos.steps > 0) {
                    textEl.setAttribute("x", bestPos.x);
                    textEl.setAttribute("y", bestPos.y);
                    
                    // 如果你有背景框，这里也需要同步更新背景框位置
                    // 简单的办法是重新触发一次背景框绘制，或者手动在此处更新 text-bg
                    const bgId = textEl.id + "-bg"; // 假设你的背景id规则是这样
                    const bgEl = document.getElementById(bgId);
                    if(bgEl) {
                        // 背景通常是 rect，x/y 是左上角
                        // 需要重新计算 rect 的 x,y
                        bgEl.setAttribute("x", bestPos.x - w/2 - (s.textBgPadding || 3));
                        bgEl.setAttribute("y", bestPos.y - h/2 - (s.textBgPadding || 3));
                    }
                }
            });
        }
    </script>
    
    <script id="script_step_6">
        // ==========================================
        // Step 6: 绘制初始场景
        // 定义全局常量，供后续步骤复用
        // ==========================================
        
        const CX = 480;
        const CY = 420;     // 地面基准线
        const SCALE = 14;   // 1分米 = 14像素
        const S = 8 * SCALE; // 棱长 8分米 = 112px
        
        const GAP_Y = 80;   // 右侧上下长方体的垂直间距
        const DIST_X = 80;  // 左右物体与中心线的距离
        
        // 计算位置坐标 (全局)
        const x_left = -DIST_X - S; // 左侧正方体 X (右边缘在 -DIST_X)
        const x_right = DIST_X;     // 右侧长方体 X (左边缘在 DIST_X)
        const h_cut = S / 2;        // 切割高度
        
        // 1. 左侧正方体 (Left Cube)
        drawCuboid({
            id: "cube-main",
            x: x_left, y: 0, z: 0,
            w: S, h: S, d: S,
            centerX: CX, centerY: CY,
            styles: {
                faceFill: "rgba(255,255,255,0.8)",
                edgeStroke: "#333",
                edgeWidth: 2
            }
        });
        
        // 1.1 标注棱长 "8分米"
        drawDimensionLabel({
            id: "dim-cube-main-w",
            p1: { x: x_left, y: 0, z: 0 },
            p2: { x: x_left + S, y: 0, z: 0 },
            direction: "下",
            text: "8分米",
            centerX: CX, centerY: CY,
            styles: {
                gap: 15,
                textOffset: 20
            }
        });
        
        // 1.2 绘制切割虚线环 (Rectangular Loop)
        // 手动创建元素时，使用 svg 变量挂载
        const p_fl = Projections.OBLIQUE(x_left,     h_cut, 0, { centerX: CX, centerY: CY });
        const p_fr = Projections.OBLIQUE(x_left + S, h_cut, 0, { centerX: CX, centerY: CY });
        const p_br = Projections.OBLIQUE(x_left + S, h_cut, S, { centerX: CX, centerY: CY });
        const p_bl = Projections.OBLIQUE(x_left,     h_cut, S, { centerX: CX, centerY: CY });
        
        const cutGroup = document.createElementNS(SVG_NS, "g");
        cutGroup.setAttribute("id", "cut-lines");
        const cutPoly = document.createElementNS(SVG_NS, "polygon");
        cutPoly.setAttribute("points", `${p_fl.px},${p_fl.py} ${p_fr.px},${p_fr.py} ${p_br.px},${p_br.py} ${p_bl.px},${p_bl.py}`);
        cutPoly.setAttribute("fill", "rgba(225, 29, 72, 0.1)");
        cutPoly.setAttribute("stroke", "#e11d48");
        cutPoly.setAttribute("stroke-width", "2");
        cutPoly.setAttribute("stroke-dasharray", "6,4");
        cutGroup.appendChild(cutPoly);
        
        // 挂载到 svg 容器
        svg.appendChild(cutGroup);
        
        // 2. 右侧两个分离的长方体 (Right Cuboids)
        // 2.1 下半部分
        drawCuboid({
            id: "cube-bottom",
            x: x_right, y: 0, z: 0,
            w: S, h: h_cut, d: S,
            centerX: CX, centerY: CY,
            styles: {
                faceFill: "white",
                edgeStroke: "#333"
            }
        });
        
        // 2.2 上半部分 (悬空)
        const y_top_start = h_cut + GAP_Y;
        drawCuboid({
            id: "cube-top",
            x: x_right, y: y_top_start, z: 0,
            w: S, h: h_cut, d: S,
            centerX: CX, centerY: CY,
            styles: {
                faceFill: "rgba(255,255,255,0.9)", 
                edgeStroke: "#333"
            }
        });
        
        // 3. 水平指示箭头
        // 位置逻辑：设定在物体深度的一半 (z=S/2)，并在此深度的平面上计算左右留白
        const arrowMargin = 30; // 留白距离
        const arrowZ = S / 2;   // 深度中点
        const arrowY = S / 2;   // 高度中点
        
        // 左起点：左侧物体右边缘 + margin
        const pArrowStart = Projections.OBLIQUE(x_left + S + arrowMargin, arrowY, arrowZ, { centerX: CX, centerY: CY });
        // 右终点：右侧物体左边缘 - margin
        const pArrowEnd   = Projections.OBLIQUE(x_right - arrowMargin,    arrowY, arrowZ, { centerX: CX, centerY: CY });
        
        drawArrow({
            id: "arrow-process",
            x1: pArrowStart.px, y1: pArrowStart.py,
            x2: pArrowEnd.px,   y2: pArrowEnd.py,
            styles: {
                stroke: "#666",
                fill: "#666",
                arrowSize: 10,
                strokeWidth: 2.5
            }
        });
        </script>
        
        <script id="script_step_10">
        // ==========================================
        // Step 10: 高亮新增切面
        // ==========================================
        // 局部常量
        const highlightColor = "rgba(239, 68, 68, 0.5)"; 
        const strokeColor = "#dc2626"; 
        
        // 1. 下方长方体顶面
        const faceBottomTop = document.getElementById("cube-bottom-face-top");
        if (faceBottomTop) {
            faceBottomTop.setAttribute("fill", highlightColor);
            faceBottomTop.setAttribute("stroke", strokeColor);
            faceBottomTop.setAttribute("stroke-width", "2");
        }
        
        // 2. 上方长方体底面
        const faceTopBottom = document.getElementById("cube-top-face-bottom");
        if (faceTopBottom) {
            faceTopBottom.setAttribute("fill", highlightColor);
            faceTopBottom.setAttribute("stroke", strokeColor);
            faceTopBottom.setAttribute("stroke-width", "2");
        }
        </script>
        
        <script id="script_step_15">
        // ==========================================
        // Step 15: 标注新增切面的边长 "8分米"
        // 复用 Step 6 定义的 x_right, S, h_cut, GAP_Y, CX, CY
        // ==========================================
        
        // 1. 标注下方长方体切面 (顶面)
        drawDimensionLabel({
            id: "dim-cut-bottom",
            p1: { x: x_right + S, y: h_cut, z: 0 },
            p2: { x: x_right + S, y: h_cut, z: S },
            direction: "右",
            text: "8分米",
            centerX: CX, centerY: CY,
            styles: {
                gap: 10,
                ext_length: 10
            }
        });
        
        // 2. 标注上方长方体切面 (底面)
        // 上方长方体的底面高度 = h_cut + GAP_Y (即 y_top_start)
        const y_cut_top = h_cut + GAP_Y;
        
        drawDimensionLabel({
            id: "dim-cut-top",
            p1: { x: x_right + S, y: y_cut_top, z: 0 },
            p2: { x: x_right + S, y: y_cut_top, z: S },
            direction: "右",
            text: "8分米",
            centerX: CX, centerY: CY,
            styles: {
                gap: 10,
                ext_length: 10
            }
        });
        </script>
</body>
</html>